









Domain Cell Map Service
=======================


contents
--------
- adding dirents and dirs
- generating a rule id
- adding children to a domain cell's child list
- mapping nested cels efficiently
- put new map cell
- create new mapcel from rule id and length


mapping technology overview
---------------------------
(10/12/17)

  dcel file handle
     frag cursor

first we create a "mapping" production instruction which takes a source dcel and a scanner id, and generates a new dcel which contains a hierarchy of mapcels.  it also updates and shares the frag-map from the source dcel.

the scanner reads the stream from the dcel file handle.  when it generates a mapcel, it adds the mapcel to the fragment pointed to by the frag cursor.

if multiple mapcels reduce to a higher rank mapcel, those cells are listed as children in the higher cell and the higher cell is added to the cursor's fragment.

if a cell is deemed a dirent, the map service creates a production instruction from the mapcel, fragment, source dcel; then executes the instruction to generate a new dcel.  the dcel is added to the directory at the top of the directory stack in the file handle.

when the top directory is finalized, the map service creates a production instruction as before to create a dirent dcel, and then pops the top directory from the file handle and saves it in the new dcel.  the new dcel is added to the next directory at the top of the stack.

(this constrains every directory to become a dirent in the previous directory on the stack)

under this model, the directory is never a part of the semantic value of a scanner's grammar rule.(2017-10-12)

the semantic value of gammar rules are mapcels. (2017-10-12)
mapcels are implemented by dcels. (2017-11-07)

the dcel file handle tracks the fragment location via the frag cursor; it tracks the directory hierarchy position via the directory stack.

the scan is finalized by taking the final, highest ranking mapcel, adding it and the source's root fragment and the final directory to a new dcel.  the dcel is returned as the result.  this is the result of the mapping production instruction.

the fragment will have been updated via the map service's use of the frag cursor.




   

adding dirents and dirs
-----------------------
(rev 10/12/17)

a directory is held in a dcel.

there may be multiple layers of scanner rule separation between a directory and its dirents.

a dirent may be created by the scanner before its directory is created.

    dcel_mapsvc_new_dirent( ... )

the dcel_mapsvc_new_dirent() function creates a dirent and holds it on a dir stack in the dcel_fh.

when the parser makes a directory dcel, it pops the top of the dir stack and gives it to the dcel.

    dcel_mapsvc_finish_dir( ... )

a directory is part of the semantic value of a mapcel.  dirents are mapcel pointers. (9/20/17)

a simple directory implementation is an array of mapcel pointers:(9/21/17)

    mapcel_t **dir;
    int num_entries;

the above assumes all entries share the same frag.  a sequence of arrays, each with a header, addresses this shortcoming.

    sequence block[]
        frag ptr
        num elements
        array[]


generating a rule id
--------------------

goal:
- rule id fits into sizeof(void *)
- rule id fits btree key type
- rule id includes scanner id
- rule id includes scanner rule id
- rule id maps to a legible string


solution:  (sunny side up)

rule id is a hash of a string.
it does not include scanner id.
there is only global namespace. 
adequate for proof of concept.

there is no scanner ruleid-str map.  just one hash function which takes a string and returns a value compatible with 'void *'.


implementation:  (sunny side up)

    uint64_t hsp->str_hash( str );

    alias:
    uint64_t hsp->ruleid( str );


solution:  (over easy)

rule id is two int's.  first is scanner id, second is rule id.

this is in union with void *

where void * is twice size of int.

the void * can be used as bkey_t

each scanner has a table of ruleid's, mapping to string id's.

string id's are of the format:

    scanner::rulename


implementation:

the scanner bison file defines a map table between string ids and token numbers.

    id_map = { token, "token" };

the scanner handle provides a function to translate token number into global ruleid.

    hsp_tok_gid( hsp, token );

the scanner library generates a scanner id for each scanner.  it generates a global ruleid table.  when it loads a scanner, it parses the string-id map into the global table.  the strings are added to a string table and mapped to the global ids.  global ids are generated by combining the scanner id with the rule id.

    slib_init_scanner_id( scanlib, scanner );

    slib_init_rule_gid_tab( scanlib );
    slib_init_scanner_tok_map( scanlib, scanner );


objects:
    slib_rule_gid_tab
    slib_rule_str_map
    scanner_rule_id_map



adding children to a domain cell's child list
-----------------------

dcel child list is an evaluated result of query on the frag map

child records are stored in map anchors

inputs:
- dcel file handle
- child mapcel
- child length
- child starting offset

outputs:
- updated dcel via file handle:
  child record stored in map anchor

procedure:
- calculate length remaining from starting offset to end of dcel
- make sure child fits remaining length
- get map anchor at starting offset
- add child to map anchor, keyed by child length



## mapping nested cels efficiently ##

if new cel's pos is same as cur pos
    add to mapanchor at cur pos
else
    wait until "add" function
    when add child to new cel
    take the first child's anchor

implementation:
    dcel_mapsvc_new_term
        finds deepest map anchor 
    dcel_mapsvc_new
        does not find anchor
    dcel_mapsvc_add
        use first child anchor





## put new map cell ##

inputs:
  rule id
  length
  frag cursor:
      root cursor node:
          frag, frag offset
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...
      current map anchor


outputs:
  new map cell
  updated frag cursor:
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...
      current map anchor


procedure:

- find the deepest fragment which accomodates length

- create new mapcel from rule id and length

- get head and tail anchors for mapcel within fragment

- store new mapcel at anchors by rule id




## create new mapcel from rule id and length ##
aka("mapcel_new()")





## get head and tail anchors within fragment for mapcel ##

in:
  fragment
  offset
  length

out:
  head anchor
  tail anchor

procedure:
  btree insert algorithm
  returns value if exists
  otherwise generates new value

  for head anchor at offset
  for tail anchor at offset + length
  





## find the deepest fragment which accomodates length ##
aka( fragcurse_deepest_has_room )

in:
  length
  frag cursor:
      root cursor node:
          frag, frag offset
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...
      current map anchor

out:
  updated frag cursor:
      root cursor node:
          frag, frag offset
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...

procedure:

    @ does fragment have room?
        ( frag_has_room() )

    -yes-    `fcf:`
    @ find child fragment
        ( bnode_value_at_key_or_nearest_lesser() )

    @ does ( child ) fragment have room?
        ( frag_has_room() )

        -yes-
        step into child fragment
        repeat `fcf`

        -no-
        update cursor
            to frag, frag offset


    -no-     `fpf:`
    step out to parent fragment
    @ does fragment have room?
        ( frag_has_room() )

        -no-
        goto `fpf`

        -yes-
        update cursor
            to frag, frag offset




### find child fragment ###
### search fragment btree for offset ###
aka( frag_child_contains_offset() )
aka( bnode_value_at_key_or_nearest_lesser )

in:
  btree
  desired key (offset)

out:
  value at key (frag)
  found key (offset)

procedure:
  btree insert operation
  without insert

  nearest key <= offset

  at btree node
  get range of keys
  split range
  select range which holds offset
  split range...
  until ranges are one key each
  if key is eq. to offset
    child frag is value at key
    child offset is 0
  if no branch links
    child frag is key < offset
    child offset is offset - key
  else
    repeat `at btree node` at appropriate branch link





### does fragment have room? ###
aka( frag_has_room() )

in:
  fragment
      length
  offset
  length

out:
  TRUE -or- FALSE


procedure:
  if length + offset is less than fragment's length return TRUE else FALSE


