




production instruction implementation
======================

- producer modules

- rationale

- production instructions and scanner mapping

- production functions and instructions

- production engine

- implementation



producer modules
----------------

a producer module has:

    - a production function
    - stream service functions
    - sync check functions

the service functions overload the standard dcel service functions.

ie.  bind-cascade module overloads dcel_write().  (bind-cascade creates a product of dcel 1 and 2, the result is dcel 3.  but writes must happen to dcel 2 or the cascade is not a cascade.)



rationale
---------

A production instruction's purpose is 
- generate dcel
- distributable processing
- rebuild cache
- data binding


The production instruction belongs to a target dcel.  It has a pointer to a source dcel.  It produces the target dcel.

A production instruction has sync check functions that can be called by cosmos.


If the source is dirty, it must be synced and the production instruction re-run.

The sync algo may alter the production instruction and or dcel.

If the production fails, the target is obsolete.  If it succeeds, the result is compared to the target; merged if different, discarded if same.

all productions must fit this model.



## example ##

a source dcel

   x{abcd}

a production instruction

   select * from "x" where "name" is "c";

a result

   c


a change in the frag map of the source

   x{acbd}

the target's production instruction

    select * from "x" where "name" is "c";

a result

    c

compare to target: the target has not changed, therefor the dcel memory object remains valid, as do it's references.  it should take the place of the "c" object in the updated source dcel's child list.



domain map validation
---------------------

if the parent dcel's checksum changes, the children may be invalid.

they are still valid if their checksum exists inside the map somewhere.

remember, the checksum may be more intelligent than a mathematical hash function.  it may 

scanner rule-path constraint:  allows a dcel to revalidate against an reconfigured mapcel hierarchy.


production instruction requirements for scanner mapping
---------------------------

to rebuild a map dcel from scratch we need

  - source dcel
  - scanner id
  - rule id
  - ordinal
  - rule id "path"
      (calc'd fr map)
  - rule id "path" constraint
      (set by scanner)



production instructions generated by a scanner mapping
---------------------------

The domain can change in two ways:  The order of its set; the content of its set.

In theory, if the order changes, a map cel can still be valid if it's checksum value is still valid.

(checksum may be complex, calculated from the dcel's canonicalized content map, not just its bytestream.)

the info that can rebuild a map dcel:
  
  fragment underlyer
  clipping "window" of frag
  checksum function for dcel
  checksum value
  parent map dcel
  source dcel for full map rebuild
  scanner and rule full map rebuild


## frag validation ##

To validate a mapping, the production instruction needs to reference the underlying fragment.  This can be done with a "window frag" - a map dcel's top fragment. If the fragment does not change, the dcel is valid.

## content validation ##

If the underlying fragment changes, it cannot be guaranteed that the map dcel will be valid.  The scanner will have to be re-run on the frag at the least, maybe the source dcel at the most.

Each map dcel's production instruction needs a checksum function (this can be a module or part of a module.)

If the map dcel's order within its parent map dcel changes, but the dcel's chcecksum is still present within the parent set, the dcel may be merged into the parent set.

## merging ##

merging is performed by keeping the original dcel object but swapping in the fragment info from the re-generated dcel.  also swap the dcel into the fragment's map anchor.




production functions and instructions
-----------------


a producer function:

        dcel *(*)(context_frame *, int argc, void **argv);


a production instruction:

    prod instr
        prod fn
        contx frame
        argc
        argv


ie.
   {dsource, myctx, 1, filepath}
   {dfind_sql, myctx, sqlc, sqlv}
   {dbind, myctx, dcelc, dcelv}
   {dgrind, myctx, argc, argv}
   


## production engine ##

the production instruction execution engine.

  dcel *prod_exec( prod_instr * );



## source function ##

the source function expects a url string.

        dsource( ... "file:///abc.txt" );



## bind function ##

the binder expects its argv to be dcels.  an array of dcels will suffice:

        dcel *dc[n];
        ...
        dc_new = dbind( dc );



## find function ##

a find function searches for and selects a map dcel from a source dcel.

the mapcel becomes the root mapcel of the result dcel.  result dcel's root fragment is a window of the (possibly larger) root fragment in the source dcel.  a window fragment has start and end boundaries which shall be respected during dcel service operations.


## grind function ##

the grinder casts its argv thus:

        argv[]={
            dcel *(*)(int, void **),
            void *,
            void *,
            ...
        };


the grind prod_fn expects a function pointer as its first argument.  the fnptr has a type of:

        dcel *(*)(int, void **);

the remainder args are passed to the function pointer.


## context frames ##

at its most robust, a context frame is an execution environment instance, which can be executed on any grid node and produce identical results.

at a bare minimum it is empty and ignored.

the environment



implementation
--------------


    prod instr
        aframe to prod fn
        fn ptr

