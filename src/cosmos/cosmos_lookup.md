

table of contents
-----------------

- header file
- lookup architecture
- generic cosmos lookup algorithm
- lookup axis theory
- binds vs. cascades
- cosmos lookup algorithm
- stream content cache buffer

and older stuff



header file
-----------

cosmos_fs.h
  cosmos_lookup() 



lookup architecture
-------------------

cosmos_lookup() is the entry point.

cosmos_lookup() uses lookup modules, relative to each access frame.

a lookup module supplies a lookupfn() to interpret a request string.

the lookupfn() implements a data access language interpreter.  ie: sql, java script, filepath.

lookupfn() makes calls to cosmos_lookup_svc.

'cosmos_lookup_svc' is the actual interface to the data.  (lookupfn() doesn't need to do anything complicated, only to direct the use of cosmos_lookup_svc.)



cache and sync
--------------

the aframe tree is a cache of successful lookups.

if the lookup string matches a branch of the aframe tree, use the branch.

if the branch passes the sync check, use the branch.

if the branch fails the sync check, sync the branch: re-run the production instruction for the aframe's dcel.

if the lookup string does not match a branch of the aframe tree, run the lookupfn from the aframe's parent.



empty aframes
-------------

empty aframes, those without dcels, can be used to construct a path.  empty aframes can have branches.

test for sync succeeds.  ('no dcel' is in sync with 'no source'.)




empty dcels
-----------

empty dcels, that have been bound to a service but which are not mapped, are in sync because the map is unmapped.

test for sync succeeds.  ('no map' is in sync with itself.)

if the dcel is mapped, it must be tested for sync.





cosmos_lookup_svc functions
---------------------------

the lookup_svc provides functions for querying dcels:

  find_dirent
  find_property
  find_mapcel
  map
  transform

the find family of functions queries a map that was generated by the map function or a transform function.

map and transform are provided by modules.  map uses the service module from the target aframe.  transform uses a module from the target's parent's metadirectory.






generic cosmos lookup algorithm
-------------------------------

ex.

  result_aframe
  cosmos_lookup(db, aframe, str);


algo


  steps
  - sync aframe
  - find str in branch-cache
  - find aframe->lookupfn
  - get aframe's dcel's svc module
  - lookupfn(db, aframe, str)
  - lookup_svc_<*>(db, aframe, ...)
  - save str,result in branch-cache
  - return result


  triggers
  - lookup_svc_find_<*>() triggers lookup_svc_map() as needed



1) check aframe sync
   - empty aframe Su 
   - 
   -on fail-
   

1)

  lookupfn = aframe->par->lookupfn

  pathseg = aframe

  pathstr = local_lookup_pathname


2)

  look in aframe->branch cache for string 
  -or-
  look in aframe->branch cache for string->next_segment()

  if result, return result
  -else-
  

2)

  map pathseg using pathseg's service

  lookup next pathseg using lookupfn


  repeat 2)


3) find local lookupfn.

  lookupfn = local_lookupfn

  pathseg = aframe

  pathstring = string


  do subroutine 2)


ex.

  a/b.c.d/e

  production chain:

  a/ from map(a)   // uses a->svc
  b from find(a,b)
  c from trans(b,c)
  d from trans(c,d)
  d/ from map(d)   // uses d->svc
  e from find(d,e)



specifically, the lookupfn deligates to the functions of the generic lookup_svc.  (see lookup_svc)



lookup axis theory
------------------
(2018/06/08)

a lookup happens on an axis defined by a linkage of access frames.

- branch axis
- bind axis

the lookup has directionality along the axis.

- forward
- reverse

a lookup origin can be stationary or traveling (along an axis.)

- stationary
- traveling


the combinations we are interested in are:

- static-origin, forward-branch lookup (regular)
- reverse-branch traveling-origin, forward-branch lookup (cascade)
- forward-bind traveling-origin, forward-branch lookup (bind)


these methods implement the three kinds of lookup:

- regular
- cascade
- bind


binds vs. cascades
------------------

a cascade happens within a filetree from parent to child node.

a bind happens accross file trees between child nodes.

a bind can merge two nodes from different media together into the same semantic node.

a bind is complex where data must be merged: two nodes with the same address but differing content.  sync  algorithms must be used.

also, a mechanism for accessing one individual or another from the bind should be available.




cosmos lookup algorithm
-----------------------
(2018/06/08)


functions
- cosmos_lookup
- cosmos_lookup_cascade
- cosmos_lookup_bind
- lookup_cache
- lookup_map


cosmos_lookup( par, pathstr )
   for seg in pathstr
      if r=lookup_cache( par, seg ) 
      || r=lookup_map( par, seg )
         return r
      else
         return NULL
    

lookup_map( par, pathseg )
   if r=find child in par.map NONE
      mapfn = cosmos_lookup_cascade( par.par, pathtomapper ) OK
      if exec_mapfn( mapfn, par )
        r=find child in par.map
   return r || NULL


cosmos_lookup_cascade( par, pathstr )
   while par OK
   && ! r=cosmos_lookup( par, pathstr )
      par = par.par
   return r || NULL




   
   
stream content cache buffer
---------------------------







cascade lookup
--------------
cosmos_lookup() implements cascade behavior as described in cosmos_cascade.md


meta-dir recursion loop while looking for modules can be avoided by performing reverse tree lookup.






child list - map implementation
-------------------------------


dcel child list key

  uintptr_t, uintptr_t


first 8 bytes is hash of file basename wout suffix

second 8 is hash of suffix









cosmos lookup
-------------

inputs:

cosmos database
cosmos ino 
request string


output:

cosmos ino
modifies inode
modifies request cache
modifies dcel map



description:

cosmos_lookup takes a request string.  (a path string from snafu.)

cosmos_lookup checks the lookup cache in the inode.

cosmos_lookup deligates the request to the lookup function referenced in the inode.

the deligate function parses the string and returns an ino.





procedure:

1. look in the cache
2. run the lookup function


a)
get string id
get cache branch at string id
else (b)

b)
get parent access frame's (inode) lookup module.

use it to lookup current frame's (inode) internal lookup module from the cur frame's ".cosm" branch.

use the internal lookup module to lookup path string in cur frame.

put result in cache at string id



detail:

lookfn = par->lookfn;

ilookfn = lookfn( cosmos database, access frame, internal lookfn path string );

ilookfn( cosmos database, access frame, path string );


example:

cosmos_lookup( db, mountpoint frame, relative path );




module lookups
--------------


a bind product

  dcel:{ module_id: "file" }


a lookup

  .cosm/lib/cosmos/modules/file.so/cosmos_map_fn





optomize
---------

             on every creation

aframe
   par
   lookupfn



vs

aframe
   par

vs

aframe
   branch
      "../.cosm/lookup.fn"


--

             on every lookup

aframe/lookup_mod()

vs

lookup_pathwalk( aframe/par, pathstr )

vs

lookup_branch( aframe, pathstr )



--
which happens more? aframe create or aframe lookup?

put the overhead on the least frequent operation.



access frames are created by the init procedure and by the lookup procedure.

