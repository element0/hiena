









Domain Cell Map Service
=======================


contents
--------
- adding dirents and dirs
- generating a rule id
- adding children to a domain cell's child list
- mapping nested cels efficiently
- put new map cell
- create new mapcel from rule id and length


adding dirents and dirs
-----------------------
a directory is held in a mapcel.

there may be one or more layers of grammar rulespace separation between a directory and its dirents.

a dirent may be created by the parser before its directory is created.

    dcel_mapsvc_new_dirent( ... )

the dcel_mapsvc_new_dirent() function creates a dirent and holds it on a directory builder stack in the dcel file handle.

when the parser creates a directory mapcel, it consumes the directory builder stack and incorporates the dirents.

    dcel_mapsvc_new_dircel( ... )



generating a rule id
--------------------

goal:
- rule id fits into sizeof(void *)
- rule id fits btree key type
- rule id includes scanner id
- rule id includes scanner rule id
- rule id maps to a legible string


solution:  (sunny side up)

rule id is a hash of a string.
it does not include scanner id.
there is only global namespace. 
adequate for proof of concept.

there is no scanner ruleid-str map.  just one hash function which takes a string and returns a value compatible with 'void *'.


implementation:  (sunny side up)

    uint64_t hsp->str_hash( str );

    alias:
    uint64_t hsp->ruleid( str );


solution:  (over easy)

rule id is two int's.  first is scanner id, second is rule id.

this is in union with void *

where void * is twice size of int.

the void * can be used as bkey_t

each scanner has a table of ruleid's, mapping to string id's.

string id's are of the format:

    scanner::rulename


implementation:

the scanner bison file defines a map table between string ids and token numbers.

    id_map = { token, "token" };

the scanner handle provides a function to translate token number into global ruleid.

    hsp_tok_gid( hsp, token );

the scanner library generates a scanner id for each scanner.  it generates a global ruleid table.  when it loads a scanner, it parses the string-id map into the global table.  the strings are added to a string table and mapped to the global ids.  global ids are generated by combining the scanner id with the rule id.

    slib_init_scanner_id( scanlib, scanner );

    slib_init_rule_gid_tab( scanlib );
    slib_init_scanner_tok_map( scanlib, scanner );


objects:
    slib_rule_gid_tab
    slib_rule_str_map
    scanner_rule_id_map



adding children to a domain cell's child list
-----------------------

dcel child list is an evaluated result of query on the frag map

child records are stored in map anchors

inputs:
- dcel file handle
- child mapcel
- child length
- child starting offset

outputs:
- updated dcel via file handle:
  child record stored in map anchor

procedure:
- calculate length remaining from starting offset to end of dcel
- make sure child fits remaining length
- get map anchor at starting offset
- add child to map anchor, keyed by child length



## mapping nested cels efficiently ##

if new cel's pos is same as cur pos
    add to mapanchor at cur pos
else
    wait until "add" function
    when add child to new cel
    take the first child's anchor

implementation:
    dcel_mapsvc_new_term
        finds deepest map anchor 
    dcel_mapsvc_new
        does not find anchor
    dcel_mapsvc_add
        use first child anchor





## put new map cell ##

inputs:
  rule id
  length
  frag cursor:
      root cursor node:
          frag, frag offset
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...
      current map anchor


outputs:
  new map cell
  updated frag cursor:
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...
      current map anchor


procedure:

- find the deepest fragment which accomodates length

- create new mapcel from rule id and length

- get head and tail anchors for mapcel within fragment

- store new mapcel at anchors by rule id




## create new mapcel from rule id and length ##
aka("mapcel_new()")





## get head and tail anchors within fragment for mapcel ##

in:
  fragment
  offset
  length

out:
  head anchor
  tail anchor

procedure:
  btree insert algorithm
  returns value if exists
  otherwise generates new value

  for head anchor at offset
  for tail anchor at offset + length
  





## find the deepest fragment which accomodates length ##
aka( fragcurse_deepest_has_room )

in:
  length
  frag cursor:
      root cursor node:
          frag, frag offset
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...
      current map anchor

out:
  updated frag cursor:
      root cursor node:
          frag, frag offset
      current cursor node:
          frag, frag offset,
          outer cursor node
              ...

procedure:

    @ does fragment have room?
        ( frag_has_room() )

    -yes-    `fcf:`
    @ find child fragment
        ( bnode_value_at_key_or_nearest_lesser() )

    @ does ( child ) fragment have room?
        ( frag_has_room() )

        -yes-
        step into child fragment
        repeat `fcf`

        -no-
        update cursor
            to frag, frag offset


    -no-     `fpf:`
    step out to parent fragment
    @ does fragment have room?
        ( frag_has_room() )

        -no-
        goto `fpf`

        -yes-
        update cursor
            to frag, frag offset




### find child fragment ###
### search fragment btree for offset ###
aka( frag_child_contains_offset() )
aka( bnode_value_at_key_or_nearest_lesser )

in:
  btree
  desired key (offset)

out:
  value at key (frag)
  found key (offset)

procedure:
  btree insert operation
  without insert

  nearest key <= offset

  at btree node
  get range of keys
  split range
  select range which holds offset
  split range...
  until ranges are one key each
  if key is eq. to offset
    child frag is value at key
    child offset is 0
  if no branch links
    child frag is key < offset
    child offset is offset - key
  else
    repeat `at btree node` at appropriate branch link





### does fragment have room? ###
aka( frag_has_room() )

in:
  fragment
      length
  offset
  length

out:
  TRUE -or- FALSE


procedure:
  if length + offset is less than fragment's length return TRUE else FALSE


